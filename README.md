# opensouce-project
# 1. top(탑)

### **top**  명령어는 현재 OS의 상태를 나타내주는 CLI 어플리케이션입니다.


###### 메모리 사용량, CPU 사용량 등을 나타내주며 top를 실행하는 동안에는 주기적인 업데이트로 실시간에 근접한 내용을 보여줍니다. 리눅스에서 top 명령어를 실행하면 아래와 깉이 노출됩니다. 위에는 전체의 요약이 있으며 아래에는 각 프로세스마다 구체적인 내용을 포함하고 있습니다.
<img width="1280" height="375" alt="dhvmsthm" src="https://github.com/user-attachments/assets/6ffacee9-89dc-4ad3-ab38-1c73f243cf41" />


>  요약 영역은 top에서 상단에 위치하고 있습니다. 이 요약영역은 전체 프로세스가 OS에 대해서 리소스를 어느정도 차지하고 있는지를 알려줍니다. 요약 영역에 나타나는 대표적인 값은 시간, 유저, 로드 에버리지(Load Average), 테스크(Tasks), CPU, 메모리(memory)로 아래의 이미지 를 보시면 각 영역에 대해 나태내느 값이 어디에 위치하는지 알 수 있습니다.


## top(탑) 사용법

+  top
+  top -o %CPU
+  top -o %MEM
 
### top 명령어 실행 예시
```bash
top - 15:22:41 up 2:11, 1명의 사용자, 부하 평균: 0.12, 0.08, 0.06
작업: 총 184개, 실행 중 1개, 대기 중 183개, 중지됨 0개, 좀비 0개
%Cpu(s): 5.3 us, 1.2 sy, 0.0 ni, 92.9 id, 0.4 wa, 0.0 hi, 0.1 si, 0.0 st
MiB 메모리: 총 7856.0개, 사용 가능 1250.3개, 사용됨 2203.7개, buff/cache 4401.9개
MiB 스왑: 총 2048.0개, 사용 가능 2048.0개, 사용됨 0.0개, 사용 가능한 메모리 5231.1개
```


| PID  | USER | PR | NI |   VIRT   |  RES  |  SHR  | S | %CPU | %MEM |   TIME+   | COMMAND      |
|------|------|----|----|----------|-------|-------|---|------|------|-----------|---------------|
| 1421 | root | 20 |  0 |  414504  | 65728 | 50284 | S |  8.5 |  0.8 |  0:32.45 | Xorg          |
| 1864 | user | 20 |  0 | 1523040  |136924 | 89432 | S |  4.3 |  1.7 |  1:12.63 | gnome-shell   |
| 2542 | user | 20 |  0 | 1274528  | 64840 | 50128 | S |  2.0 |  0.8 |  0:18.21 | firefox       |
| 3678 | user | 20 |  0 |  245612  | 20348 | 16432 | R |  1.0 |  0.2 |  0:01.12 | top           |
| 1001 | root | 20 |  0 |  164892  | 12880 |  9984 | S |  0.0 |  0.2 |  0:03.22 | systemd       |



---

# 2.  ps(피에스)

### **ps** 명령어는 Process State의 약자로 현재 실행 중인 프로세스와 상태를 출력하는 명령어입니다. 
> man ps를 사용 시 ps 명령어와 관련된 매뉴얼을 볼 수 있는데, ps 명령어의 옵션은 
각 시스템 계열 System V(-), BSD(- 사용 안 함), GNU(--)마다 다른 표기법 및 출력을 가지고 있습니다. 그래서 만약 제가 포스트한 명령어 옵션이 의도대로 사용이 안 된다면 꼭 man ps를 통해서 옵션 표기 및 설명을 확인해보시길 바랍니다. 

보통 grep 명령어와 많이 사용됩니다.
[출처] ps 명령어 및 옵션 - 리눅스 프로세스 관리 [Linux 명령어]|작성자 tmk0429

## ps 명령어 출력 항목 
| 항목 | 설명 |
|------|------|
| USER (BSD) | 프로세스 소유자의 이름 |
| UID (System V) | 프로세스 소유자의 이름 |
| PID | 프로세스의 식별 번호 |
| PPID | 부모 프로세스의 PID |
| %CPU | CPU 사용 비율의 추정치 (BSD) |
| %MEM | Memory 사용 비율의 추정치 (BSD) |
| VSZ | K 단위 또는 페이지 단위의 가상 메모리 사용량 |
| RSS | 실제 메모리 사용량 |
| TTY | 프로세스와 연결된 터미널 |
| S (System V) / STAT (BSD) | 현재 프로세스의 상태 코드 |
| TIME | 총 CPU 사용 시간 |
| COMMAND | 프로세스의 실행 명령행 |
| STIME | 프로세스가 시작된 시간 또는 날짜 |
| C (System V) / CP (BSD) | 짧은 기간 동안의 CPU 사용률 |
| F | 플래그 |
| PRI | 실제 실행 우선순위 |
| NI | nice 우선순위 번호 |


## ps 사용법
```
1 ps
2 ps aux
3 ps -ef
4 ps -ef | grep [프로세스명]
5 ps aux | grep [프로세스명]
```
**참고**
<https://blog.naver.com/tmk0429/222318530824>

---

# 3. jobs(잡스)

### **jobs** 명령어는 현재 셸에서 실행 중인 작업 목록을 확인합니다.
> 리눅스에서 jobs 명령어는 현재 쉘 세션에서 실행 중이거나 일시 중지된 작업(프로세스)을 확인할 때 사용됩니다. 백그라운드나 포그라운드에서 실행되는 작업들을 목록으로 보여주며, 각 작업에 대한 상태 정보도 함께 제공합니다. 주로 작업 제어 명령어인 fg, bg, kill과 함께 사용되며, 이 명령어들은 특정 작업을 포그라운드로 전환하거나 백그라운드에서 실행하거나, 작업을 종료할 때 유용합니다.

### jobs 명령어의 예시
> 아래는 리눅스 터미널에서 jobs 명령어를 사용하는 예제입니다. ping 명령어를 백그라운드로 실행한 뒤, jobs 명령어를 사용해 상태를 확인하는 과정입니다.
<img width="892" height="172" alt="image" src="https://github.com/user-attachments/assets/4c457469-7cb9-4170-97eb-35418bb720ee" />


##  사용법
<img width="899" height="85" alt="image" src="https://github.com/user-attachments/assets/47bcc5f6-d8a3-423d-b238-7ba986ac6d1c" />

```
1.jobs
2. fg %1
3. bg %1
```

---
**참고**
<https://monkeybusiness.tistory.com/630>

# 4. kill(킬)

### **kill** 명령어는 단순 종료 명령어가 아니라 프로세스에 지정한 시그널(Signal)을 보내는 명령어입니다. 해당 시그널의 액션이 종료라면 프로세스가 종료하게 되는 것입니다.
> killall 명령어는 kill 명령어와 유사하지만 프로세스 지정을 프로세스 이름으로 합니다. (kill 명령어는 프로세스 번호로 프로세스를 지정)
>
*시그널을 발생시키는 이벤트*
+ Hardware Exception
+ Software Condition
+ 사용자의 입력
+ kill 명령어와 같은 시스템 콜
  
### 시그널 종류
| 번호 | 시그널 이름 | 설명 | 기본 동작 |
|------|--------------|-------------------------------|-----------|
| 1  | SIGHUP   | 연결 끊기 (프로세스의 설정 파일을 다시 읽는데 사용), 실행 종료 | 종료 |
| 2  | SIGINT   | 인터럽트, 실행 종료 (Ctrl + C) | 종료 |
| 3  | SIGQUIT  | Quit, 실행 종료 (Ctrl + \) | 종료 |
| 4  | SIGILL   | 잘못된 명령 | 종료 |
| 5  | SIGTRAP  | trace, breakpoint에서 TRAP 발생 | 종료 |
| 6  | SIGIOT   | IOT 명령 | 종료 |
| 7  | SIGBUS   | 버스 에러 | 종료 |
| 8  | SIGFPE   | 부동 소수점 예외 | 종료 |
| 9  | SIGKILL  | 무조건적으로 즉시 종료 (잡거나 무시 불가) | 종료 |
| 10 | SIGUSR1  | 사용자 정의 시그널 1 | 종료 |
| 11 | SIGSEGV  | Segmentation fault, 허가되지 않은 메모리 영역 접근 | 종료 |
| 12 | SIGUSR2  | 사용자 정의 시그널 2 | 종료 |
| 13 | SIGPIPE  | 읽을 것이 없는 파이프에 대한 시그널 | 종료 |
| 14 | SIGALRM  | 경보 시그널 | 종료 |
| 15 | SIGTERM  | 소프트웨어 종료 요청 시그널 | 종료 |
| 16 | SIGTSTP  | 프로세스의 스톱 신호 | 무시 |
| 17 | SIGCHLD  | 프로세스 종료 시 부모 프로세스에게 보내지는 시그널 | 무시 |
| 18 | SIGCONT  | STOP이나 TSTP 시그널에 의해 정지된 프로세스를 다시 시작 | 계속 |
| 19 | SIGSTOP  | 정지 시그널 (TSTP와 같지만 무시할 수 없음) | 프로세스 정지 |
| 20 | SIGTSTP  | 실행을 잠시 멈추고 다시 실행을 계속하기 위해 보냄 (Ctrl + Z) | 프로세스 정지 |



##  사용법
```
1. kill <PID>
2. kill -9 <PID>
3. kill -15 <PID>
```
참고 
<https://m.blog.naver.com/tmk0429/222322701794>
---
